**1.SpringMVC运行原理**

1. 客户端请求提交到DispatcherServlet
2. 由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。
3. Controller调用业务逻辑处理后，返回ModelAndView
4. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图
5. 视图负责将结果显示到客户端

**2.HashMap与HashTable的区别**

1.HashMap是非线程安全的，HashTable是线程安全的。
2.HashMap的键和值都允许有null值存在，而HashTable则不行。
3.因为线程安全的问题，HashMap效率比HashTable的要高。

**3.HashMap的实现机制**

1. 维护一个每个元素是一个链表的数组，而且链表中的每个节点是一个Entry[]键值对的数据结构。
2. 实现了数组+链表的特性，查找快，插入删除也快。
3. 对于每个key,他对应的数组索引下标是 int i = hash(key.hashcode)&(len-1);
4. 每个新加入的节点放在链表首，然后该新加入的节点指向原链表首

**4.Linux常用命令：**cd，cp，mv，rm，ps（进程），tar，cat(查看内容)，chmod，vim，find，ls

**5.进程和线程的区别：**

进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。

线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。

线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

多进程是指操作系统能同时运行多个任务（程序）。

多线程是指在同一程序中有多个顺序流在执行。

在java中要想实现多线程，有三种手段，一种是继承Thread类，另外一种是实现Runable接口，还有就是实现Callable接口。

**6.Object有哪些公用方法？**

a.方法equals测试的是两个对象是否相等

b.方法clone进行对象拷贝

c.方法getClass返回和当前对象相关的Class对象

d.方法notify,notifyall,wait都是用来对给定对象进行线程同步的

**7.Override和Overload的含义以及区别**

a.Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。
b.就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。
具体可前往C++中重载、重写（覆盖）的区别实例分析查看

<u>**8.抽象类和接口的区别**</u>

a.一个类只能继承单个类，但是可以实现多个接口

b.抽象类中可以有构造方法，接口中不能有构造方法

c.抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的，且必须重写接口中定义的所有方法。

d.抽象类中可以包含静态方法，接口中不可以

e.抽象类中可以有普通成员变量，接口中不可以

**9.wait()和sleep()的区别**

sleep来自Thread类，和wait来自Object类

调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁

sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU

sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒

**10.JAVA 中堆和栈的区别，说下java 的内存机制**

a.基本数据类型比变量和对象的引用都是在栈分配的

b.堆内存用来存放由new创建的对象和数组

c.类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中

d.实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存

e.局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放

**11.索引的优化**

MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。

尽量不要写!=或者<>的sql，用between或> and <代替，否则可能用不到索引

Order by 、Group by 、Distinct 最好在需要这个列上建立索引，利于索引排序

尽量利用mysql索引排序

没办法的情况下，使用强制索引Force index(index_name)

尽量避勉innodb用非常大尺寸的字段作为主键

较频繁的作为查询条件的字段应该创建索引;

选择性高的字段比较适合创建索引;

作为表关联字段一般都需要创索引.

更新非常频繁的字段不适合创建索引;

不会出现在 WHERE 子句中的字段不该创建索引.

选择性太低的字段不适合单独创建索引

**12.mybatis中"#（）"和“$（）”的区别**

#{}是预编译处理，${}是字符串替换。mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。

（1）$符号一般用来当作占位符，常使用Linux脚本的人应该对此有更深的体会吧。既然是占位符，当然就是被用来替换的。知道了这点就能很容易区分$和#，从而不容易记错了。
（2）预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。

# 1.Spring面试题

## 1.1.Spring 在ssm中起什么作用？

- Spring：轻量级框架
- 作用：Bean工厂，用来管理Bean的生命周期和框架集成。
- 两大核心： 1、IOC/DI(控制反转/依赖注入) ：把dao依赖注入到service层，service层反转给action层，Spring顶层容器为BeanFactory。 2、AOP：面向切面编程

## 1.2.Spring的事务？

- 编程式事务管理：编程方式管理事务，极大灵活性，难维护。
- 声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。

# 2.集合

## 2.1.什么是迭代器(Iterator)？

- 链接：https://www.nowcoder.com/questionTerminal/8863f297b1fc4bbca6de95528b6051e1来源：牛客网

  ```
  每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作. 
  有一点需要注意的是：
  Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,
  每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.
  有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException
  异常. 但是可以通过Iterator接口中的remove()方法进行删除., 否则会抛出ConcurrentModificationException
  异常. 但是可以通过Iterator接口中的remove()方法进行删除.
  
  (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
  (2) 使用next()获得序列中的下一个元素。
  (3) 使用hasNext()检查序列中是否还有元素。
  (4) 使用remove()将迭代器新返回的元素删除。
  ```